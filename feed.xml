<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">
  <channel>
    <title>libisky</title>
    <link>http://libisy.com/</link>
    <description>阐述遇到的各种问题，分享踩过的各种坑，记录懒得记的各种命令</description>
    <managingEditor> (libi)</managingEditor>
    <pubDate>Thu, 28 Jul 2016 14:30:56 +0800</pubDate>
    <item>
      <title>Thrift在php框架laravel中的应用</title>
      <link>http://libisy.com/2016/7/28/thrfit_in_laravel.html</link>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;最近在项目中遇到需要跨系统调用的需求，找了很多rpc框架对比,因为其他部分项目使用了golang语言，为了考虑日后系统间调用更加灵活，所以决定使用thrift框架。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;thrif简介&#34;&gt;Thrif简介&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Thrift是一个支持跨语言(支持但不限于php,golang,java,c++,Ruby,Node.js等)支持远程调用rpc的软件框架.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thrift定义了一个简单的数据类型和服务接口标准，在使用时只需要实现定义好需要用的数据类型与服务（近似理解成调用函数）到.thrfit文件,使用thrfit指令生成对应版本的语言即刻,在下面会说如何编写.thrfit文件&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;thrift在osx下的安装&#34;&gt;Thrift在osx下的安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;需要注意的是，thrift并不需要安装到服务器，只需要安装到你自己的开发机上，使用指令生成对应对应开发语言的代码就可以了。&#xA; 我使用的系统是osx10.10，用的最简单的homebrew安装方式，只需要一行指令即刻&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;brew install thrift&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在等待片刻后,键入thrift命令看到thrift帮助指令即安装成功.&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;thrift文件定义&#34;&gt;.thrift文件定义&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;接下来我们需要根据项目需求来定义thrift文件,thrift支持的数据类型如下：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本类型：&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bool：布尔值，true 或 false，对应 Java 的 boolean&lt;/li&gt;&#xA;&lt;li&gt;byte：8 位有符号整数，对应 Java 的 byte&lt;/li&gt;&#xA;&lt;li&gt;i16：16 位有符号整数，对应 Java 的 short&lt;/li&gt;&#xA;&lt;li&gt;i32：32 位有符号整数，对应 Java 的 int&lt;/li&gt;&#xA;&lt;li&gt;i64：64 位有符号整数，对应 Java 的 long&lt;/li&gt;&#xA;&lt;li&gt;double：64 位浮点数，对应 Java 的 double&lt;/li&gt;&#xA;&lt;li&gt;string：utf-8编码的字符串，对应 Java 的 String&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;结构体类型：&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;struct：定义公共的对象，类似于 C 语言中的结构体定义，在 Java 中是一个 JavaBean&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;容器类型：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;list：对应 Java 的 ArrayList&lt;/li&gt;&#xA;&lt;li&gt;set：对应 Java 的 HashSet&lt;/li&gt;&#xA;&lt;li&gt;map：对应 Java 的 HashMap&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;异常类型：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;exception：对应 Java 的 Exception&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;服务类型：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;service：对应服务的类&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;在知道大概的基础数据类型以后，我们来举个例子，假如有2个系统，分别提供用户信息服务和订单服务，订单服务在接受到订单请求时需要获取用户信息。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据需求，我们可以定义一个服务类叫做 user ，它提供一个getinfo函数供调用，该函数需要传入一个整型的uid，返回一个map（定义struct更为准确，这里为了演示方便使用map）,写成user.thrift文件如下所示&#xA;    namespace php user //命名空间&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;service user{&#xA;        map&amp;lt;i32,string&amp;gt; getinfo(1:i32 uid)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;代码生成&#34;&gt;代码生成&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;定义好服务（类）以后，使用thrift -r -gen 命令接口生成各个语言对应的代码版本&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;thrift -r -gen php:server user.thrift &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;命令执行成功以后会在改目录下生成一个gen-php的目录，直接在具体项目中引入即刻。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;laravel框架调用&#34;&gt;laravel框架调用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;thrift官网提供了各个语言版本的类库供调用,项目地址：&lt;a href=&#34;https://github.com/apache/thrift/&#34;&gt;https://github.com/apache/thrift/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;php版本使用composer依赖库进行管理,laravel集成了composer包管理，所以只需要执行&#xA;    composer require apache/thrift&#xA;即可引入成功，在其他php项目中引入请参见compser说明&lt;/p&gt;&#xA;&#xA;&lt;p&gt;引入类库以后需要继续引入上一步生成的协议代码,这里我将gen-php文件夹里的user文件夹复制到laravel的跟目录的thrift目录下，并且在composer.json中添加&#xA;    &amp;ldquo;autoload&amp;rdquo;{&#xA;        &amp;ldquo;classmap&amp;rdquo;:[&#xA;            &amp;ldquo;thrift&amp;rdquo;&#xA;        ]&#xA;    }&#xA;执行下面代码即刻引入成功&#xA;    composer dump-auto&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;laravel服务端添加代码&#34;&gt;laravel服务端添加代码&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在laravel控制器中添加以下代码，并绑定路由&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;use Thrift\Transport\TBufferedTransport;&#xA;use Thrift\Protocol\TBinaryProtocol;&#xA;use Thrift\Transport\THttpClient;&#xA;use Thrift\Transport\TPhpStream;&#xA;header(&#39;Content-Type&#39;, &#39;application/x-thrift&#39;);&#xA;    $handler = new user();//这里是定义在服务端提供服务的类&#xA;    $processor = new \thrift\opasProcessor($handler);&#xA;&#xA;&#xA;    $transport = new TBufferedTransport(new TPhpStream(TPhpStream::MODE_R | TPhpStream::MODE_W));&#xA;    $protocol = new TBinaryProtocol($transport, true, true);&#xA;&#xA;    $transport-&amp;gt;open();&#xA;    $processor-&amp;gt;process($protocol, $protocol);&#xA;    $transport-&amp;gt;close();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;添加类服务定义,绑定\user\userIf接口&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class user implements \user\userIf{&#xA;    function getinfo($uid){&#xA;        $user = User::find($uid);&#xA;        return $user;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;laravel客户端添加代码&#34;&gt;laravel客户端添加代码&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这里使用http协议调用远程方法，代码如下&#xA;    try {&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;        $socket = new THttpClient(&#39;www.xxx.com&#39;, 80, &#39;/thrift/server&#39;);//服务端定义的url&#xA;&#xA;        $transport = new TBufferedTransport($socket, 1024, 1024);&#xA;        $protocol = new TBinaryProtocol($transport);&#xA;        $client = new thrift\opasClient($protocol);&#xA;&#xA;        $transport-&amp;gt;open();&#xA;&#xA;&#xA;        $result = $client-&amp;gt;getinfo(1);//调用远程方法&#xA;        $transport-&amp;gt;close();&#xA;        return $result;&#xA;&#xA;    } catch (TException $tx) {&#xA;        print &#39;TException: &#39;.$tx-&amp;gt;getMessage().&amp;quot;\n&amp;quot;;&#xA;        return null;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在上面的getinfo方法返回的是一个对象,直接复制代码运行会接收不到返回值，可以修改为返回一个array(&amp;ldquo;key&amp;rdquo;=&amp;gt;&amp;ldquo;value&amp;rdquo;)数组即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本文内容纯属个人理解，如有错误纰漏欢迎大家指正。&lt;/p&gt;&#xA;</description>
      <author>libi</author>
      <pubDate>Thu, 28 Jul 2016 11:52:33 +0000</pubDate>
    </item>
    <item>
      <title>新的开始</title>
      <link>http://libisy.com/2016/1/22/restart.html</link>
      <description>&lt;h3 id=&#34;惨痛教训&#34;&gt;惨痛教训&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;libisky.com在我断断续续的更新下维持了3年时间，最终因为服务器到期忘记续费，文章数据等全部丢失。懊悔之余真正认识到养成定时备份的习惯的重要性。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;静态博客与go语言&#34;&gt;静态博客与go语言&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;博客要重新开始，在考虑了很久以后决定使用静态博客程序，使用md跟写代码一样写文章，编译生成静态文件，用户访问速度快的同时，自己也觉得感觉逼格满满。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为对go语言的好感，所以使用了 fuxiaohei 的pugo，刚开始不久，各种特性就不在此阐述了，大家可以&lt;a href=&#34;https://github.com/go-xiaohei/pugo&#34;&gt;在此&lt;/a&gt;查看&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;新的开始&#34;&gt;新的开始&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;从新开始以后会着重归纳日常工作中解决的问题和思路，记录常用的一些脚本命令，还有一些学习路线轨迹等。&lt;/p&gt;&#xA;</description>
      <author>libi</author>
      <pubDate>Fri, 22 Jan 2016 00:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>